This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of a subset of the repository's contents that is considered the most important context.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: examples/
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
pb/
  upstox-market-data.pb.go
go.mod
manager.go
types.go
upstox-market-data.proto
websocket.go
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="pb/upstox-market-data.pb.go">
// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.8
// 	protoc        v6.32.0
// source: upstox-market-data.proto

package pb

import (
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type Type int32

const (
	Type_initial_feed Type = 0
	Type_live_feed    Type = 1
	Type_market_info  Type = 2
)

// Enum value maps for Type.
var (
	Type_name = map[int32]string{
		0: "initial_feed",
		1: "live_feed",
		2: "market_info",
	}
	Type_value = map[string]int32{
		"initial_feed": 0,
		"live_feed":    1,
		"market_info":  2,
	}
)

func (x Type) Enum() *Type {
	p := new(Type)
	*p = x
	return p
}

func (x Type) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Type) Descriptor() protoreflect.EnumDescriptor {
	return file_upstox_market_data_proto_enumTypes[0].Descriptor()
}

func (Type) Type() protoreflect.EnumType {
	return &file_upstox_market_data_proto_enumTypes[0]
}

func (x Type) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Type.Descriptor instead.
func (Type) EnumDescriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{0}
}

type RequestMode int32

const (
	RequestMode_ltpc          RequestMode = 0
	RequestMode_full_d5       RequestMode = 1
	RequestMode_option_greeks RequestMode = 2
	RequestMode_full_d30      RequestMode = 3
)

// Enum value maps for RequestMode.
var (
	RequestMode_name = map[int32]string{
		0: "ltpc",
		1: "full_d5",
		2: "option_greeks",
		3: "full_d30",
	}
	RequestMode_value = map[string]int32{
		"ltpc":          0,
		"full_d5":       1,
		"option_greeks": 2,
		"full_d30":      3,
	}
)

func (x RequestMode) Enum() *RequestMode {
	p := new(RequestMode)
	*p = x
	return p
}

func (x RequestMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (RequestMode) Descriptor() protoreflect.EnumDescriptor {
	return file_upstox_market_data_proto_enumTypes[1].Descriptor()
}

func (RequestMode) Type() protoreflect.EnumType {
	return &file_upstox_market_data_proto_enumTypes[1]
}

func (x RequestMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use RequestMode.Descriptor instead.
func (RequestMode) EnumDescriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{1}
}

type MarketStatus int32

const (
	MarketStatus_PRE_OPEN_START MarketStatus = 0
	MarketStatus_PRE_OPEN_END   MarketStatus = 1
	MarketStatus_NORMAL_OPEN    MarketStatus = 2
	MarketStatus_NORMAL_CLOSE   MarketStatus = 3
	MarketStatus_CLOSING_START  MarketStatus = 4
	MarketStatus_CLOSING_END    MarketStatus = 5
)

// Enum value maps for MarketStatus.
var (
	MarketStatus_name = map[int32]string{
		0: "PRE_OPEN_START",
		1: "PRE_OPEN_END",
		2: "NORMAL_OPEN",
		3: "NORMAL_CLOSE",
		4: "CLOSING_START",
		5: "CLOSING_END",
	}
	MarketStatus_value = map[string]int32{
		"PRE_OPEN_START": 0,
		"PRE_OPEN_END":   1,
		"NORMAL_OPEN":    2,
		"NORMAL_CLOSE":   3,
		"CLOSING_START":  4,
		"CLOSING_END":    5,
	}
)

func (x MarketStatus) Enum() *MarketStatus {
	p := new(MarketStatus)
	*p = x
	return p
}

func (x MarketStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (MarketStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_upstox_market_data_proto_enumTypes[2].Descriptor()
}

func (MarketStatus) Type() protoreflect.EnumType {
	return &file_upstox_market_data_proto_enumTypes[2]
}

func (x MarketStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use MarketStatus.Descriptor instead.
func (MarketStatus) EnumDescriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{2}
}

type LTPC struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ltp           float64                `protobuf:"fixed64,1,opt,name=ltp,proto3" json:"ltp,omitempty"`
	Ltt           int64                  `protobuf:"varint,2,opt,name=ltt,proto3" json:"ltt,omitempty"`
	Ltq           int64                  `protobuf:"varint,3,opt,name=ltq,proto3" json:"ltq,omitempty"`
	Cp            float64                `protobuf:"fixed64,4,opt,name=cp,proto3" json:"cp,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LTPC) Reset() {
	*x = LTPC{}
	mi := &file_upstox_market_data_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LTPC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LTPC) ProtoMessage() {}

func (x *LTPC) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LTPC.ProtoReflect.Descriptor instead.
func (*LTPC) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{0}
}

func (x *LTPC) GetLtp() float64 {
	if x != nil {
		return x.Ltp
	}
	return 0
}

func (x *LTPC) GetLtt() int64 {
	if x != nil {
		return x.Ltt
	}
	return 0
}

func (x *LTPC) GetLtq() int64 {
	if x != nil {
		return x.Ltq
	}
	return 0
}

func (x *LTPC) GetCp() float64 {
	if x != nil {
		return x.Cp
	}
	return 0
}

type MarketLevel struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BidAskQuote   []*Quote               `protobuf:"bytes,1,rep,name=bidAskQuote,proto3" json:"bidAskQuote,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketLevel) Reset() {
	*x = MarketLevel{}
	mi := &file_upstox_market_data_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketLevel) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketLevel) ProtoMessage() {}

func (x *MarketLevel) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketLevel.ProtoReflect.Descriptor instead.
func (*MarketLevel) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{1}
}

func (x *MarketLevel) GetBidAskQuote() []*Quote {
	if x != nil {
		return x.BidAskQuote
	}
	return nil
}

type MarketOHLC struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ohlc          []*OHLC                `protobuf:"bytes,1,rep,name=ohlc,proto3" json:"ohlc,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketOHLC) Reset() {
	*x = MarketOHLC{}
	mi := &file_upstox_market_data_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketOHLC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketOHLC) ProtoMessage() {}

func (x *MarketOHLC) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketOHLC.ProtoReflect.Descriptor instead.
func (*MarketOHLC) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{2}
}

func (x *MarketOHLC) GetOhlc() []*OHLC {
	if x != nil {
		return x.Ohlc
	}
	return nil
}

type Quote struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	BidQ          int64                  `protobuf:"varint,1,opt,name=bidQ,proto3" json:"bidQ,omitempty"`
	BidP          float64                `protobuf:"fixed64,2,opt,name=bidP,proto3" json:"bidP,omitempty"`
	AskQ          int64                  `protobuf:"varint,3,opt,name=askQ,proto3" json:"askQ,omitempty"`
	AskP          float64                `protobuf:"fixed64,4,opt,name=askP,proto3" json:"askP,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Quote) Reset() {
	*x = Quote{}
	mi := &file_upstox_market_data_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Quote) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Quote) ProtoMessage() {}

func (x *Quote) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Quote.ProtoReflect.Descriptor instead.
func (*Quote) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{3}
}

func (x *Quote) GetBidQ() int64 {
	if x != nil {
		return x.BidQ
	}
	return 0
}

func (x *Quote) GetBidP() float64 {
	if x != nil {
		return x.BidP
	}
	return 0
}

func (x *Quote) GetAskQ() int64 {
	if x != nil {
		return x.AskQ
	}
	return 0
}

func (x *Quote) GetAskP() float64 {
	if x != nil {
		return x.AskP
	}
	return 0
}

type OptionGreeks struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Delta         float64                `protobuf:"fixed64,1,opt,name=delta,proto3" json:"delta,omitempty"`
	Theta         float64                `protobuf:"fixed64,2,opt,name=theta,proto3" json:"theta,omitempty"`
	Gamma         float64                `protobuf:"fixed64,3,opt,name=gamma,proto3" json:"gamma,omitempty"`
	Vega          float64                `protobuf:"fixed64,4,opt,name=vega,proto3" json:"vega,omitempty"`
	Rho           float64                `protobuf:"fixed64,5,opt,name=rho,proto3" json:"rho,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OptionGreeks) Reset() {
	*x = OptionGreeks{}
	mi := &file_upstox_market_data_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OptionGreeks) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OptionGreeks) ProtoMessage() {}

func (x *OptionGreeks) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OptionGreeks.ProtoReflect.Descriptor instead.
func (*OptionGreeks) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{4}
}

func (x *OptionGreeks) GetDelta() float64 {
	if x != nil {
		return x.Delta
	}
	return 0
}

func (x *OptionGreeks) GetTheta() float64 {
	if x != nil {
		return x.Theta
	}
	return 0
}

func (x *OptionGreeks) GetGamma() float64 {
	if x != nil {
		return x.Gamma
	}
	return 0
}

func (x *OptionGreeks) GetVega() float64 {
	if x != nil {
		return x.Vega
	}
	return 0
}

func (x *OptionGreeks) GetRho() float64 {
	if x != nil {
		return x.Rho
	}
	return 0
}

type OHLC struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Interval      string                 `protobuf:"bytes,1,opt,name=interval,proto3" json:"interval,omitempty"`
	Open          float64                `protobuf:"fixed64,2,opt,name=open,proto3" json:"open,omitempty"`
	High          float64                `protobuf:"fixed64,3,opt,name=high,proto3" json:"high,omitempty"`
	Low           float64                `protobuf:"fixed64,4,opt,name=low,proto3" json:"low,omitempty"`
	Close         float64                `protobuf:"fixed64,5,opt,name=close,proto3" json:"close,omitempty"`
	Vol           int64                  `protobuf:"varint,6,opt,name=vol,proto3" json:"vol,omitempty"`
	Ts            int64                  `protobuf:"varint,7,opt,name=ts,proto3" json:"ts,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *OHLC) Reset() {
	*x = OHLC{}
	mi := &file_upstox_market_data_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *OHLC) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*OHLC) ProtoMessage() {}

func (x *OHLC) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use OHLC.ProtoReflect.Descriptor instead.
func (*OHLC) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{5}
}

func (x *OHLC) GetInterval() string {
	if x != nil {
		return x.Interval
	}
	return ""
}

func (x *OHLC) GetOpen() float64 {
	if x != nil {
		return x.Open
	}
	return 0
}

func (x *OHLC) GetHigh() float64 {
	if x != nil {
		return x.High
	}
	return 0
}

func (x *OHLC) GetLow() float64 {
	if x != nil {
		return x.Low
	}
	return 0
}

func (x *OHLC) GetClose() float64 {
	if x != nil {
		return x.Close
	}
	return 0
}

func (x *OHLC) GetVol() int64 {
	if x != nil {
		return x.Vol
	}
	return 0
}

func (x *OHLC) GetTs() int64 {
	if x != nil {
		return x.Ts
	}
	return 0
}

type MarketFullFeed struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ltpc          *LTPC                  `protobuf:"bytes,1,opt,name=ltpc,proto3" json:"ltpc,omitempty"`
	MarketLevel   *MarketLevel           `protobuf:"bytes,2,opt,name=marketLevel,proto3" json:"marketLevel,omitempty"`
	OptionGreeks  *OptionGreeks          `protobuf:"bytes,3,opt,name=optionGreeks,proto3" json:"optionGreeks,omitempty"`
	MarketOHLC    *MarketOHLC            `protobuf:"bytes,4,opt,name=marketOHLC,proto3" json:"marketOHLC,omitempty"`
	Atp           float64                `protobuf:"fixed64,5,opt,name=atp,proto3" json:"atp,omitempty"`  //avg traded price
	Vtt           int64                  `protobuf:"varint,6,opt,name=vtt,proto3" json:"vtt,omitempty"`   //volume traded today
	Oi            float64                `protobuf:"fixed64,7,opt,name=oi,proto3" json:"oi,omitempty"`    //open interest
	Iv            float64                `protobuf:"fixed64,8,opt,name=iv,proto3" json:"iv,omitempty"`    //implied volatility
	Tbq           float64                `protobuf:"fixed64,9,opt,name=tbq,proto3" json:"tbq,omitempty"`  //total buy quantity
	Tsq           float64                `protobuf:"fixed64,10,opt,name=tsq,proto3" json:"tsq,omitempty"` //total sell quantity
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketFullFeed) Reset() {
	*x = MarketFullFeed{}
	mi := &file_upstox_market_data_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketFullFeed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketFullFeed) ProtoMessage() {}

func (x *MarketFullFeed) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketFullFeed.ProtoReflect.Descriptor instead.
func (*MarketFullFeed) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{6}
}

func (x *MarketFullFeed) GetLtpc() *LTPC {
	if x != nil {
		return x.Ltpc
	}
	return nil
}

func (x *MarketFullFeed) GetMarketLevel() *MarketLevel {
	if x != nil {
		return x.MarketLevel
	}
	return nil
}

func (x *MarketFullFeed) GetOptionGreeks() *OptionGreeks {
	if x != nil {
		return x.OptionGreeks
	}
	return nil
}

func (x *MarketFullFeed) GetMarketOHLC() *MarketOHLC {
	if x != nil {
		return x.MarketOHLC
	}
	return nil
}

func (x *MarketFullFeed) GetAtp() float64 {
	if x != nil {
		return x.Atp
	}
	return 0
}

func (x *MarketFullFeed) GetVtt() int64 {
	if x != nil {
		return x.Vtt
	}
	return 0
}

func (x *MarketFullFeed) GetOi() float64 {
	if x != nil {
		return x.Oi
	}
	return 0
}

func (x *MarketFullFeed) GetIv() float64 {
	if x != nil {
		return x.Iv
	}
	return 0
}

func (x *MarketFullFeed) GetTbq() float64 {
	if x != nil {
		return x.Tbq
	}
	return 0
}

func (x *MarketFullFeed) GetTsq() float64 {
	if x != nil {
		return x.Tsq
	}
	return 0
}

type IndexFullFeed struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ltpc          *LTPC                  `protobuf:"bytes,1,opt,name=ltpc,proto3" json:"ltpc,omitempty"`
	MarketOHLC    *MarketOHLC            `protobuf:"bytes,2,opt,name=marketOHLC,proto3" json:"marketOHLC,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IndexFullFeed) Reset() {
	*x = IndexFullFeed{}
	mi := &file_upstox_market_data_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IndexFullFeed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IndexFullFeed) ProtoMessage() {}

func (x *IndexFullFeed) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IndexFullFeed.ProtoReflect.Descriptor instead.
func (*IndexFullFeed) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{7}
}

func (x *IndexFullFeed) GetLtpc() *LTPC {
	if x != nil {
		return x.Ltpc
	}
	return nil
}

func (x *IndexFullFeed) GetMarketOHLC() *MarketOHLC {
	if x != nil {
		return x.MarketOHLC
	}
	return nil
}

type FullFeed struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to FullFeedUnion:
	//
	//	*FullFeed_MarketFF
	//	*FullFeed_IndexFF
	FullFeedUnion isFullFeed_FullFeedUnion `protobuf_oneof:"FullFeedUnion"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FullFeed) Reset() {
	*x = FullFeed{}
	mi := &file_upstox_market_data_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FullFeed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FullFeed) ProtoMessage() {}

func (x *FullFeed) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FullFeed.ProtoReflect.Descriptor instead.
func (*FullFeed) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{8}
}

func (x *FullFeed) GetFullFeedUnion() isFullFeed_FullFeedUnion {
	if x != nil {
		return x.FullFeedUnion
	}
	return nil
}

func (x *FullFeed) GetMarketFF() *MarketFullFeed {
	if x != nil {
		if x, ok := x.FullFeedUnion.(*FullFeed_MarketFF); ok {
			return x.MarketFF
		}
	}
	return nil
}

func (x *FullFeed) GetIndexFF() *IndexFullFeed {
	if x != nil {
		if x, ok := x.FullFeedUnion.(*FullFeed_IndexFF); ok {
			return x.IndexFF
		}
	}
	return nil
}

type isFullFeed_FullFeedUnion interface {
	isFullFeed_FullFeedUnion()
}

type FullFeed_MarketFF struct {
	MarketFF *MarketFullFeed `protobuf:"bytes,1,opt,name=marketFF,proto3,oneof"`
}

type FullFeed_IndexFF struct {
	IndexFF *IndexFullFeed `protobuf:"bytes,2,opt,name=indexFF,proto3,oneof"`
}

func (*FullFeed_MarketFF) isFullFeed_FullFeedUnion() {}

func (*FullFeed_IndexFF) isFullFeed_FullFeedUnion() {}

type FirstLevelWithGreeks struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Ltpc          *LTPC                  `protobuf:"bytes,1,opt,name=ltpc,proto3" json:"ltpc,omitempty"`
	FirstDepth    *Quote                 `protobuf:"bytes,2,opt,name=firstDepth,proto3" json:"firstDepth,omitempty"`
	OptionGreeks  *OptionGreeks          `protobuf:"bytes,3,opt,name=optionGreeks,proto3" json:"optionGreeks,omitempty"`
	Vtt           int64                  `protobuf:"varint,4,opt,name=vtt,proto3" json:"vtt,omitempty"` //volume traded today
	Oi            float64                `protobuf:"fixed64,5,opt,name=oi,proto3" json:"oi,omitempty"`  //open interest
	Iv            float64                `protobuf:"fixed64,6,opt,name=iv,proto3" json:"iv,omitempty"`  //implied volatility
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FirstLevelWithGreeks) Reset() {
	*x = FirstLevelWithGreeks{}
	mi := &file_upstox_market_data_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FirstLevelWithGreeks) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FirstLevelWithGreeks) ProtoMessage() {}

func (x *FirstLevelWithGreeks) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FirstLevelWithGreeks.ProtoReflect.Descriptor instead.
func (*FirstLevelWithGreeks) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{9}
}

func (x *FirstLevelWithGreeks) GetLtpc() *LTPC {
	if x != nil {
		return x.Ltpc
	}
	return nil
}

func (x *FirstLevelWithGreeks) GetFirstDepth() *Quote {
	if x != nil {
		return x.FirstDepth
	}
	return nil
}

func (x *FirstLevelWithGreeks) GetOptionGreeks() *OptionGreeks {
	if x != nil {
		return x.OptionGreeks
	}
	return nil
}

func (x *FirstLevelWithGreeks) GetVtt() int64 {
	if x != nil {
		return x.Vtt
	}
	return 0
}

func (x *FirstLevelWithGreeks) GetOi() float64 {
	if x != nil {
		return x.Oi
	}
	return 0
}

func (x *FirstLevelWithGreeks) GetIv() float64 {
	if x != nil {
		return x.Iv
	}
	return 0
}

type Feed struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Types that are valid to be assigned to FeedUnion:
	//
	//	*Feed_Ltpc
	//	*Feed_FullFeed
	//	*Feed_FirstLevelWithGreeks
	FeedUnion     isFeed_FeedUnion `protobuf_oneof:"FeedUnion"`
	RequestMode   RequestMode      `protobuf:"varint,4,opt,name=requestMode,proto3,enum=com.upstox.marketdatafeederv3udapi.rpc.proto.RequestMode" json:"requestMode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Feed) Reset() {
	*x = Feed{}
	mi := &file_upstox_market_data_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Feed) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Feed) ProtoMessage() {}

func (x *Feed) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Feed.ProtoReflect.Descriptor instead.
func (*Feed) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{10}
}

func (x *Feed) GetFeedUnion() isFeed_FeedUnion {
	if x != nil {
		return x.FeedUnion
	}
	return nil
}

func (x *Feed) GetLtpc() *LTPC {
	if x != nil {
		if x, ok := x.FeedUnion.(*Feed_Ltpc); ok {
			return x.Ltpc
		}
	}
	return nil
}

func (x *Feed) GetFullFeed() *FullFeed {
	if x != nil {
		if x, ok := x.FeedUnion.(*Feed_FullFeed); ok {
			return x.FullFeed
		}
	}
	return nil
}

func (x *Feed) GetFirstLevelWithGreeks() *FirstLevelWithGreeks {
	if x != nil {
		if x, ok := x.FeedUnion.(*Feed_FirstLevelWithGreeks); ok {
			return x.FirstLevelWithGreeks
		}
	}
	return nil
}

func (x *Feed) GetRequestMode() RequestMode {
	if x != nil {
		return x.RequestMode
	}
	return RequestMode_ltpc
}

type isFeed_FeedUnion interface {
	isFeed_FeedUnion()
}

type Feed_Ltpc struct {
	Ltpc *LTPC `protobuf:"bytes,1,opt,name=ltpc,proto3,oneof"`
}

type Feed_FullFeed struct {
	FullFeed *FullFeed `protobuf:"bytes,2,opt,name=fullFeed,proto3,oneof"`
}

type Feed_FirstLevelWithGreeks struct {
	FirstLevelWithGreeks *FirstLevelWithGreeks `protobuf:"bytes,3,opt,name=firstLevelWithGreeks,proto3,oneof"`
}

func (*Feed_Ltpc) isFeed_FeedUnion() {}

func (*Feed_FullFeed) isFeed_FeedUnion() {}

func (*Feed_FirstLevelWithGreeks) isFeed_FeedUnion() {}

type MarketInfo struct {
	state         protoimpl.MessageState  `protogen:"open.v1"`
	SegmentStatus map[string]MarketStatus `protobuf:"bytes,1,rep,name=segmentStatus,proto3" json:"segmentStatus,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value,enum=com.upstox.marketdatafeederv3udapi.rpc.proto.MarketStatus"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *MarketInfo) Reset() {
	*x = MarketInfo{}
	mi := &file_upstox_market_data_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *MarketInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*MarketInfo) ProtoMessage() {}

func (x *MarketInfo) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use MarketInfo.ProtoReflect.Descriptor instead.
func (*MarketInfo) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{11}
}

func (x *MarketInfo) GetSegmentStatus() map[string]MarketStatus {
	if x != nil {
		return x.SegmentStatus
	}
	return nil
}

type FeedResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Type          Type                   `protobuf:"varint,1,opt,name=type,proto3,enum=com.upstox.marketdatafeederv3udapi.rpc.proto.Type" json:"type,omitempty"`
	Feeds         map[string]*Feed       `protobuf:"bytes,2,rep,name=feeds,proto3" json:"feeds,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	CurrentTs     int64                  `protobuf:"varint,3,opt,name=currentTs,proto3" json:"currentTs,omitempty"`
	MarketInfo    *MarketInfo            `protobuf:"bytes,4,opt,name=marketInfo,proto3" json:"marketInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeedResponse) Reset() {
	*x = FeedResponse{}
	mi := &file_upstox_market_data_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeedResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeedResponse) ProtoMessage() {}

func (x *FeedResponse) ProtoReflect() protoreflect.Message {
	mi := &file_upstox_market_data_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeedResponse.ProtoReflect.Descriptor instead.
func (*FeedResponse) Descriptor() ([]byte, []int) {
	return file_upstox_market_data_proto_rawDescGZIP(), []int{12}
}

func (x *FeedResponse) GetType() Type {
	if x != nil {
		return x.Type
	}
	return Type_initial_feed
}

func (x *FeedResponse) GetFeeds() map[string]*Feed {
	if x != nil {
		return x.Feeds
	}
	return nil
}

func (x *FeedResponse) GetCurrentTs() int64 {
	if x != nil {
		return x.CurrentTs
	}
	return 0
}

func (x *FeedResponse) GetMarketInfo() *MarketInfo {
	if x != nil {
		return x.MarketInfo
	}
	return nil
}

var File_upstox_market_data_proto protoreflect.FileDescriptor

const file_upstox_market_data_proto_rawDesc = "" +
	"\n" +
	"\x18upstox-market-data.proto\x12,com.upstox.marketdatafeederv3udapi.rpc.proto\"L\n" +
	"\x04LTPC\x12\x10\n" +
	"\x03ltp\x18\x01 \x01(\x01R\x03ltp\x12\x10\n" +
	"\x03ltt\x18\x02 \x01(\x03R\x03ltt\x12\x10\n" +
	"\x03ltq\x18\x03 \x01(\x03R\x03ltq\x12\x0e\n" +
	"\x02cp\x18\x04 \x01(\x01R\x02cp\"d\n" +
	"\vMarketLevel\x12U\n" +
	"\vbidAskQuote\x18\x01 \x03(\v23.com.upstox.marketdatafeederv3udapi.rpc.proto.QuoteR\vbidAskQuote\"T\n" +
	"\n" +
	"MarketOHLC\x12F\n" +
	"\x04ohlc\x18\x01 \x03(\v22.com.upstox.marketdatafeederv3udapi.rpc.proto.OHLCR\x04ohlc\"W\n" +
	"\x05Quote\x12\x12\n" +
	"\x04bidQ\x18\x01 \x01(\x03R\x04bidQ\x12\x12\n" +
	"\x04bidP\x18\x02 \x01(\x01R\x04bidP\x12\x12\n" +
	"\x04askQ\x18\x03 \x01(\x03R\x04askQ\x12\x12\n" +
	"\x04askP\x18\x04 \x01(\x01R\x04askP\"v\n" +
	"\fOptionGreeks\x12\x14\n" +
	"\x05delta\x18\x01 \x01(\x01R\x05delta\x12\x14\n" +
	"\x05theta\x18\x02 \x01(\x01R\x05theta\x12\x14\n" +
	"\x05gamma\x18\x03 \x01(\x01R\x05gamma\x12\x12\n" +
	"\x04vega\x18\x04 \x01(\x01R\x04vega\x12\x10\n" +
	"\x03rho\x18\x05 \x01(\x01R\x03rho\"\x94\x01\n" +
	"\x04OHLC\x12\x1a\n" +
	"\binterval\x18\x01 \x01(\tR\binterval\x12\x12\n" +
	"\x04open\x18\x02 \x01(\x01R\x04open\x12\x12\n" +
	"\x04high\x18\x03 \x01(\x01R\x04high\x12\x10\n" +
	"\x03low\x18\x04 \x01(\x01R\x03low\x12\x14\n" +
	"\x05close\x18\x05 \x01(\x01R\x05close\x12\x10\n" +
	"\x03vol\x18\x06 \x01(\x03R\x03vol\x12\x0e\n" +
	"\x02ts\x18\a \x01(\x03R\x02ts\"\xd7\x03\n" +
	"\x0eMarketFullFeed\x12F\n" +
	"\x04ltpc\x18\x01 \x01(\v22.com.upstox.marketdatafeederv3udapi.rpc.proto.LTPCR\x04ltpc\x12[\n" +
	"\vmarketLevel\x18\x02 \x01(\v29.com.upstox.marketdatafeederv3udapi.rpc.proto.MarketLevelR\vmarketLevel\x12^\n" +
	"\foptionGreeks\x18\x03 \x01(\v2:.com.upstox.marketdatafeederv3udapi.rpc.proto.OptionGreeksR\foptionGreeks\x12X\n" +
	"\n" +
	"marketOHLC\x18\x04 \x01(\v28.com.upstox.marketdatafeederv3udapi.rpc.proto.MarketOHLCR\n" +
	"marketOHLC\x12\x10\n" +
	"\x03atp\x18\x05 \x01(\x01R\x03atp\x12\x10\n" +
	"\x03vtt\x18\x06 \x01(\x03R\x03vtt\x12\x0e\n" +
	"\x02oi\x18\a \x01(\x01R\x02oi\x12\x0e\n" +
	"\x02iv\x18\b \x01(\x01R\x02iv\x12\x10\n" +
	"\x03tbq\x18\t \x01(\x01R\x03tbq\x12\x10\n" +
	"\x03tsq\x18\n" +
	" \x01(\x01R\x03tsq\"\xb1\x01\n" +
	"\rIndexFullFeed\x12F\n" +
	"\x04ltpc\x18\x01 \x01(\v22.com.upstox.marketdatafeederv3udapi.rpc.proto.LTPCR\x04ltpc\x12X\n" +
	"\n" +
	"marketOHLC\x18\x02 \x01(\v28.com.upstox.marketdatafeederv3udapi.rpc.proto.MarketOHLCR\n" +
	"marketOHLC\"\xd0\x01\n" +
	"\bFullFeed\x12Z\n" +
	"\bmarketFF\x18\x01 \x01(\v2<.com.upstox.marketdatafeederv3udapi.rpc.proto.MarketFullFeedH\x00R\bmarketFF\x12W\n" +
	"\aindexFF\x18\x02 \x01(\v2;.com.upstox.marketdatafeederv3udapi.rpc.proto.IndexFullFeedH\x00R\aindexFFB\x0f\n" +
	"\rFullFeedUnion\"\xc5\x02\n" +
	"\x14FirstLevelWithGreeks\x12F\n" +
	"\x04ltpc\x18\x01 \x01(\v22.com.upstox.marketdatafeederv3udapi.rpc.proto.LTPCR\x04ltpc\x12S\n" +
	"\n" +
	"firstDepth\x18\x02 \x01(\v23.com.upstox.marketdatafeederv3udapi.rpc.proto.QuoteR\n" +
	"firstDepth\x12^\n" +
	"\foptionGreeks\x18\x03 \x01(\v2:.com.upstox.marketdatafeederv3udapi.rpc.proto.OptionGreeksR\foptionGreeks\x12\x10\n" +
	"\x03vtt\x18\x04 \x01(\x03R\x03vtt\x12\x0e\n" +
	"\x02oi\x18\x05 \x01(\x01R\x02oi\x12\x0e\n" +
	"\x02iv\x18\x06 \x01(\x01R\x02iv\"\x8a\x03\n" +
	"\x04Feed\x12H\n" +
	"\x04ltpc\x18\x01 \x01(\v22.com.upstox.marketdatafeederv3udapi.rpc.proto.LTPCH\x00R\x04ltpc\x12T\n" +
	"\bfullFeed\x18\x02 \x01(\v26.com.upstox.marketdatafeederv3udapi.rpc.proto.FullFeedH\x00R\bfullFeed\x12x\n" +
	"\x14firstLevelWithGreeks\x18\x03 \x01(\v2B.com.upstox.marketdatafeederv3udapi.rpc.proto.FirstLevelWithGreeksH\x00R\x14firstLevelWithGreeks\x12[\n" +
	"\vrequestMode\x18\x04 \x01(\x0e29.com.upstox.marketdatafeederv3udapi.rpc.proto.RequestModeR\vrequestModeB\v\n" +
	"\tFeedUnion\"\xfd\x01\n" +
	"\n" +
	"MarketInfo\x12q\n" +
	"\rsegmentStatus\x18\x01 \x03(\v2K.com.upstox.marketdatafeederv3udapi.rpc.proto.MarketInfo.SegmentStatusEntryR\rsegmentStatus\x1a|\n" +
	"\x12SegmentStatusEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12P\n" +
	"\x05value\x18\x02 \x01(\x0e2:.com.upstox.marketdatafeederv3udapi.rpc.proto.MarketStatusR\x05value:\x028\x01\"\x99\x03\n" +
	"\fFeedResponse\x12F\n" +
	"\x04type\x18\x01 \x01(\x0e22.com.upstox.marketdatafeederv3udapi.rpc.proto.TypeR\x04type\x12[\n" +
	"\x05feeds\x18\x02 \x03(\v2E.com.upstox.marketdatafeederv3udapi.rpc.proto.FeedResponse.FeedsEntryR\x05feeds\x12\x1c\n" +
	"\tcurrentTs\x18\x03 \x01(\x03R\tcurrentTs\x12X\n" +
	"\n" +
	"marketInfo\x18\x04 \x01(\v28.com.upstox.marketdatafeederv3udapi.rpc.proto.MarketInfoR\n" +
	"marketInfo\x1al\n" +
	"\n" +
	"FeedsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12H\n" +
	"\x05value\x18\x02 \x01(\v22.com.upstox.marketdatafeederv3udapi.rpc.proto.FeedR\x05value:\x028\x01*8\n" +
	"\x04Type\x12\x10\n" +
	"\finitial_feed\x10\x00\x12\r\n" +
	"\tlive_feed\x10\x01\x12\x0f\n" +
	"\vmarket_info\x10\x02*E\n" +
	"\vRequestMode\x12\b\n" +
	"\x04ltpc\x10\x00\x12\v\n" +
	"\afull_d5\x10\x01\x12\x11\n" +
	"\roption_greeks\x10\x02\x12\f\n" +
	"\bfull_d30\x10\x03*{\n" +
	"\fMarketStatus\x12\x12\n" +
	"\x0ePRE_OPEN_START\x10\x00\x12\x10\n" +
	"\fPRE_OPEN_END\x10\x01\x12\x0f\n" +
	"\vNORMAL_OPEN\x10\x02\x12\x10\n" +
	"\fNORMAL_CLOSE\x10\x03\x12\x11\n" +
	"\rCLOSING_START\x10\x04\x12\x0f\n" +
	"\vCLOSING_END\x10\x05B(Z&github.com/adeludedperson/go-upstox/pbb\x06proto3"

var (
	file_upstox_market_data_proto_rawDescOnce sync.Once
	file_upstox_market_data_proto_rawDescData []byte
)

func file_upstox_market_data_proto_rawDescGZIP() []byte {
	file_upstox_market_data_proto_rawDescOnce.Do(func() {
		file_upstox_market_data_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_upstox_market_data_proto_rawDesc), len(file_upstox_market_data_proto_rawDesc)))
	})
	return file_upstox_market_data_proto_rawDescData
}

var file_upstox_market_data_proto_enumTypes = make([]protoimpl.EnumInfo, 3)
var file_upstox_market_data_proto_msgTypes = make([]protoimpl.MessageInfo, 15)
var file_upstox_market_data_proto_goTypes = []any{
	(Type)(0),                    // 0: com.upstox.marketdatafeederv3udapi.rpc.proto.Type
	(RequestMode)(0),             // 1: com.upstox.marketdatafeederv3udapi.rpc.proto.RequestMode
	(MarketStatus)(0),            // 2: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketStatus
	(*LTPC)(nil),                 // 3: com.upstox.marketdatafeederv3udapi.rpc.proto.LTPC
	(*MarketLevel)(nil),          // 4: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketLevel
	(*MarketOHLC)(nil),           // 5: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketOHLC
	(*Quote)(nil),                // 6: com.upstox.marketdatafeederv3udapi.rpc.proto.Quote
	(*OptionGreeks)(nil),         // 7: com.upstox.marketdatafeederv3udapi.rpc.proto.OptionGreeks
	(*OHLC)(nil),                 // 8: com.upstox.marketdatafeederv3udapi.rpc.proto.OHLC
	(*MarketFullFeed)(nil),       // 9: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketFullFeed
	(*IndexFullFeed)(nil),        // 10: com.upstox.marketdatafeederv3udapi.rpc.proto.IndexFullFeed
	(*FullFeed)(nil),             // 11: com.upstox.marketdatafeederv3udapi.rpc.proto.FullFeed
	(*FirstLevelWithGreeks)(nil), // 12: com.upstox.marketdatafeederv3udapi.rpc.proto.FirstLevelWithGreeks
	(*Feed)(nil),                 // 13: com.upstox.marketdatafeederv3udapi.rpc.proto.Feed
	(*MarketInfo)(nil),           // 14: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketInfo
	(*FeedResponse)(nil),         // 15: com.upstox.marketdatafeederv3udapi.rpc.proto.FeedResponse
	nil,                          // 16: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketInfo.SegmentStatusEntry
	nil,                          // 17: com.upstox.marketdatafeederv3udapi.rpc.proto.FeedResponse.FeedsEntry
}
var file_upstox_market_data_proto_depIdxs = []int32{
	6,  // 0: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketLevel.bidAskQuote:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.Quote
	8,  // 1: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketOHLC.ohlc:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.OHLC
	3,  // 2: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketFullFeed.ltpc:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.LTPC
	4,  // 3: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketFullFeed.marketLevel:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.MarketLevel
	7,  // 4: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketFullFeed.optionGreeks:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.OptionGreeks
	5,  // 5: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketFullFeed.marketOHLC:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.MarketOHLC
	3,  // 6: com.upstox.marketdatafeederv3udapi.rpc.proto.IndexFullFeed.ltpc:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.LTPC
	5,  // 7: com.upstox.marketdatafeederv3udapi.rpc.proto.IndexFullFeed.marketOHLC:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.MarketOHLC
	9,  // 8: com.upstox.marketdatafeederv3udapi.rpc.proto.FullFeed.marketFF:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.MarketFullFeed
	10, // 9: com.upstox.marketdatafeederv3udapi.rpc.proto.FullFeed.indexFF:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.IndexFullFeed
	3,  // 10: com.upstox.marketdatafeederv3udapi.rpc.proto.FirstLevelWithGreeks.ltpc:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.LTPC
	6,  // 11: com.upstox.marketdatafeederv3udapi.rpc.proto.FirstLevelWithGreeks.firstDepth:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.Quote
	7,  // 12: com.upstox.marketdatafeederv3udapi.rpc.proto.FirstLevelWithGreeks.optionGreeks:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.OptionGreeks
	3,  // 13: com.upstox.marketdatafeederv3udapi.rpc.proto.Feed.ltpc:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.LTPC
	11, // 14: com.upstox.marketdatafeederv3udapi.rpc.proto.Feed.fullFeed:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.FullFeed
	12, // 15: com.upstox.marketdatafeederv3udapi.rpc.proto.Feed.firstLevelWithGreeks:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.FirstLevelWithGreeks
	1,  // 16: com.upstox.marketdatafeederv3udapi.rpc.proto.Feed.requestMode:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.RequestMode
	16, // 17: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketInfo.segmentStatus:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.MarketInfo.SegmentStatusEntry
	0,  // 18: com.upstox.marketdatafeederv3udapi.rpc.proto.FeedResponse.type:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.Type
	17, // 19: com.upstox.marketdatafeederv3udapi.rpc.proto.FeedResponse.feeds:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.FeedResponse.FeedsEntry
	14, // 20: com.upstox.marketdatafeederv3udapi.rpc.proto.FeedResponse.marketInfo:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.MarketInfo
	2,  // 21: com.upstox.marketdatafeederv3udapi.rpc.proto.MarketInfo.SegmentStatusEntry.value:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.MarketStatus
	13, // 22: com.upstox.marketdatafeederv3udapi.rpc.proto.FeedResponse.FeedsEntry.value:type_name -> com.upstox.marketdatafeederv3udapi.rpc.proto.Feed
	23, // [23:23] is the sub-list for method output_type
	23, // [23:23] is the sub-list for method input_type
	23, // [23:23] is the sub-list for extension type_name
	23, // [23:23] is the sub-list for extension extendee
	0,  // [0:23] is the sub-list for field type_name
}

func init() { file_upstox_market_data_proto_init() }
func file_upstox_market_data_proto_init() {
	if File_upstox_market_data_proto != nil {
		return
	}
	file_upstox_market_data_proto_msgTypes[8].OneofWrappers = []any{
		(*FullFeed_MarketFF)(nil),
		(*FullFeed_IndexFF)(nil),
	}
	file_upstox_market_data_proto_msgTypes[10].OneofWrappers = []any{
		(*Feed_Ltpc)(nil),
		(*Feed_FullFeed)(nil),
		(*Feed_FirstLevelWithGreeks)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_upstox_market_data_proto_rawDesc), len(file_upstox_market_data_proto_rawDesc)),
			NumEnums:      3,
			NumMessages:   15,
			NumExtensions: 0,
			NumServices:   0,
		},
		GoTypes:           file_upstox_market_data_proto_goTypes,
		DependencyIndexes: file_upstox_market_data_proto_depIdxs,
		EnumInfos:         file_upstox_market_data_proto_enumTypes,
		MessageInfos:      file_upstox_market_data_proto_msgTypes,
	}.Build()
	File_upstox_market_data_proto = out.File
	file_upstox_market_data_proto_goTypes = nil
	file_upstox_market_data_proto_depIdxs = nil
}
</file>

<file path="upstox-market-data.proto">
syntax = "proto3";
package com.upstox.marketdatafeederv3udapi.rpc.proto;

option go_package = "github.com/adeludedperson/go-upstox/pb";

message LTPC {
  double ltp = 1;
  int64 ltt = 2;
  int64 ltq = 3;
  double cp = 4;
}

message MarketLevel {
  repeated Quote bidAskQuote = 1;
}

message MarketOHLC {
  repeated OHLC ohlc = 1;
}

message Quote {
  int64 bidQ = 1;
  double bidP = 2;
  int64 askQ = 3;
  double askP = 4;
}

message OptionGreeks {
  double delta = 1;
  double theta = 2;
  double gamma = 3;
  double vega = 4;
  double rho = 5;
}

message OHLC {
  string interval = 1;
  double open = 2;
  double high = 3;
  double low = 4;
  double close = 5;
  int64 vol = 6;
  int64 ts = 7;
}

enum Type{
  initial_feed = 0;
  live_feed = 1;
  market_info = 2;
}

message MarketFullFeed{
  LTPC ltpc = 1;
  MarketLevel marketLevel = 2;
  OptionGreeks optionGreeks = 3;
  MarketOHLC marketOHLC = 4;
  double atp = 5; //avg traded price
  int64 vtt = 6; //volume traded today
  double oi = 7; //open interest
  double iv = 8; //implied volatility 
  double tbq =9; //total buy quantity
  double tsq = 10; //total sell quantity
}

message IndexFullFeed{
  LTPC ltpc = 1;
  MarketOHLC marketOHLC = 2;
}


message FullFeed {
  oneof FullFeedUnion {
    MarketFullFeed marketFF = 1;
    IndexFullFeed indexFF = 2;
  }
}

message FirstLevelWithGreeks{
  LTPC ltpc = 1;
  Quote firstDepth = 2;
  OptionGreeks optionGreeks = 3;
  int64 vtt = 4; //volume traded today
  double oi = 5; //open interest
  double iv = 6; //implied volatility 
}

message Feed {
  oneof FeedUnion {
    LTPC ltpc = 1;
    FullFeed fullFeed = 2;
    FirstLevelWithGreeks firstLevelWithGreeks = 3;
  }
  RequestMode requestMode = 4;
}

enum RequestMode {
  ltpc = 0;
  full_d5 = 1;
  option_greeks = 2;
  full_d30 = 3;
}

enum MarketStatus {
  PRE_OPEN_START = 0;
  PRE_OPEN_END = 1;
  NORMAL_OPEN = 2;
  NORMAL_CLOSE = 3;
  CLOSING_START = 4;
  CLOSING_END = 5;
}


message MarketInfo {
  map<string, MarketStatus> segmentStatus = 1;
}

message FeedResponse{
  Type type = 1;
  map<string, Feed> feeds = 2;
  int64 currentTs = 3;
  MarketInfo marketInfo = 4;
}
</file>

<file path="go.mod">
module github.com/adeludedperson/go-upstox

go 1.23.3

require (
	github.com/google/uuid v1.6.0
	github.com/gorilla/websocket v1.5.3
	google.golang.org/protobuf v1.34.2
)
</file>

<file path="types.go">
package upstox

import "time"

type OrderSide string

const (
	OrderSideBuy  OrderSide = "BUY"
	OrderSideSell OrderSide = "SELL"
)

type SubscriptionMode string

const (
	ModeLTPC         SubscriptionMode = "ltpc"
	ModeFull         SubscriptionMode = "full"
	ModeOptionGreeks SubscriptionMode = "option_greeks"
	ModeFullD30      SubscriptionMode = "full_d30"
)

type MarketStatus string

const (
	MarketStatusPreOpenStart MarketStatus = "PRE_OPEN_START"
	MarketStatusPreOpenEnd   MarketStatus = "PRE_OPEN_END"
	MarketStatusNormalOpen   MarketStatus = "NORMAL_OPEN"
	MarketStatusNormalClose  MarketStatus = "NORMAL_CLOSE"
	MarketStatusClosingStart MarketStatus = "CLOSING_START"
	MarketStatusClosingEnd   MarketStatus = "CLOSING_END"
)

type LTPCData struct {
	LTP float64 `json:"ltp"`
	LTT int64   `json:"ltt"`
	LTQ int64   `json:"ltq"`
	CP  float64 `json:"cp"`
}

type Quote struct {
	BidQ int64   `json:"bidQ"`
	BidP float64 `json:"bidP"`
	AskQ int64   `json:"askQ"`
	AskP float64 `json:"askP"`
}

type OptionGreeks struct {
	Delta float64 `json:"delta"`
	Theta float64 `json:"theta"`
	Gamma float64 `json:"gamma"`
	Vega  float64 `json:"vega"`
	Rho   float64 `json:"rho"`
}

type OHLC struct {
	Interval string  `json:"interval"`
	Open     float64 `json:"open"`
	High     float64 `json:"high"`
	Low      float64 `json:"low"`
	Close    float64 `json:"close"`
	Volume   int64   `json:"vol"`
	TS       int64   `json:"ts"`
}

type MarketFullFeed struct {
	LTPC         *LTPCData     `json:"ltpc,omitempty"`
	MarketLevel  []Quote       `json:"marketLevel,omitempty"`
	OptionGreeks *OptionGreeks `json:"optionGreeks,omitempty"`
	MarketOHLC   []OHLC        `json:"marketOHLC,omitempty"`
	ATP          float64       `json:"atp,omitempty"`
	VTT          int64         `json:"vtt,omitempty"`
	OI           float64       `json:"oi,omitempty"`
	IV           float64       `json:"iv,omitempty"`
	TBQ          float64       `json:"tbq,omitempty"`
	TSQ          float64       `json:"tsq,omitempty"`
}

type IndexFullFeed struct {
	LTPC       *LTPCData `json:"ltpc,omitempty"`
	MarketOHLC []OHLC    `json:"marketOHLC,omitempty"`
}

type FullFeedData struct {
	MarketFF *MarketFullFeed `json:"marketFF,omitempty"`
	IndexFF  *IndexFullFeed  `json:"indexFF,omitempty"`
}

type FirstLevelWithGreeks struct {
	LTPC         *LTPCData     `json:"ltpc,omitempty"`
	FirstDepth   *Quote        `json:"firstDepth,omitempty"`
	OptionGreeks *OptionGreeks `json:"optionGreeks,omitempty"`
	VTT          int64         `json:"vtt,omitempty"`
	OI           float64       `json:"oi,omitempty"`
	IV           float64       `json:"iv,omitempty"`
}

type FeedData struct {
	LTPC                 *LTPCData             `json:"ltpc,omitempty"`
	FullFeed             *FullFeedData         `json:"fullFeed,omitempty"`
	FirstLevelWithGreeks *FirstLevelWithGreeks `json:"firstLevelWithGreeks,omitempty"`
	RequestMode          SubscriptionMode      `json:"requestMode"`
}

type MarketInfo struct {
	SegmentStatus map[string]MarketStatus `json:"segmentStatus"`
}

type MarketInfoMessage struct {
	Type       string      `json:"type"`
	CurrentTS  int64       `json:"currentTs"`
	MarketInfo *MarketInfo `json:"marketInfo"`
}

type LiveFeedMessage struct {
	Type      string               `json:"type"`
	Feeds     map[string]*FeedData `json:"feeds"`
	CurrentTS int64                `json:"currentTs"`
}

type MarketInfoCallback func(MarketInfoMessage)
type LiveFeedCallback func(LiveFeedMessage)

type SubscriptionRequest struct {
	GUID   string `json:"guid"`
	Method string `json:"method"`
	Data   struct {
		Mode           string   `json:"mode"`
		InstrumentKeys []string `json:"instrumentKeys"`
	} `json:"data"`
}

type AuthorizeResponse struct {
	Status string `json:"status"`
	Data   struct {
		AuthorizedRedirectURI string `json:"authorized_redirect_uri"`
	} `json:"data"`
}

type InstrumentSubscription struct {
	Mode SubscriptionMode
	Time time.Time
}

type ProductType string

const (
	ProductIntraday ProductType = "I"
	ProductDelivery ProductType = "D"
	ProductMTF      ProductType = "MTF"
)

type OrderType string

const (
	OrderTypeMarket OrderType = "MARKET"
	OrderTypeLimit  OrderType = "LIMIT"
	OrderTypeSL     OrderType = "SL"
	OrderTypeSLM    OrderType = "SL-M"
)

type ValidityType string

const (
	ValidityDay ValidityType = "DAY"
	ValidityIOC ValidityType = "IOC"
)

type OrderRequest struct {
	Quantity          int     `json:"quantity"`
	Product           string  `json:"product"`
	Validity          string  `json:"validity"`
	Price             float64 `json:"price"`
	Tag               string  `json:"tag,omitempty"`
	InstrumentToken   string  `json:"instrument_token"`
	OrderType         string  `json:"order_type"`
	TransactionType   string  `json:"transaction_type"`
	DisclosedQuantity int     `json:"disclosed_quantity"`
	TriggerPrice      float64 `json:"trigger_price"`
	IsAMO             bool    `json:"is_amo"`
	Slice             bool    `json:"slice"`
}

type OrderResponseData struct {
	OrderIDs []string `json:"order_ids"`
}

type OrderMetadata struct {
	Latency int `json:"latency"`
}

type OrderError struct {
	ErrorCode     string `json:"error_code"`
	Message       string `json:"message"`
	PropertyPath  string `json:"property_path"`
	InvalidValue  string `json:"invalid_value"`
	InstrumentKey string `json:"instrument_key"`
	OrderID       string `json:"order_id"`
}

type OrderSummary struct {
	Total   int `json:"total"`
	Success int `json:"success"`
	Error   int `json:"error"`
}

type OrderResponse struct {
	Status   string             `json:"status"`
	Data     *OrderResponseData `json:"data,omitempty"`
	Metadata *OrderMetadata     `json:"metadata,omitempty"`
	Errors   []OrderError       `json:"errors,omitempty"`
	Summary  *OrderSummary      `json:"summary,omitempty"`
}

type Position struct {
	Exchange              string  `json:"exchange"`
	Multiplier            float64 `json:"multiplier"`
	Value                 float64 `json:"value"`
	PNL                   float64 `json:"pnl"`
	Product               string  `json:"product"`
	InstrumentToken       string  `json:"instrument_token"`
	AveragePrice          float64 `json:"average_price"`
	BuyValue              float64 `json:"buy_value"`
	OvernightQuantity     int     `json:"overnight_quantity"`
	DayBuyValue           float64 `json:"day_buy_value"`
	DayBuyPrice           float64 `json:"day_buy_price"`
	OvernightBuyAmount    float64 `json:"overnight_buy_amount"`
	OvernightBuyQuantity  int     `json:"overnight_buy_quantity"`
	DayBuyQuantity        int     `json:"day_buy_quantity"`
	DaySellValue          float64 `json:"day_sell_value"`
	DaySellPrice          float64 `json:"day_sell_price"`
	OvernightSellAmount   float64 `json:"overnight_sell_amount"`
	OvernightSellQuantity int     `json:"overnight_sell_quantity"`
	DaySellQuantity       int     `json:"day_sell_quantity"`
	Quantity              int     `json:"quantity"`
	LastPrice             float64 `json:"last_price"`
	Unrealised            float64 `json:"unrealised"`
	Realised              float64 `json:"realised"`
	SellValue             float64 `json:"sell_value"`
	TradingSymbol         string  `json:"trading_symbol"`
	ClosePrice            float64 `json:"close_price"`
	BuyPrice              float64 `json:"buy_price"`
	SellPrice             float64 `json:"sell_price"`
}

type Order struct {
	Exchange          string  `json:"exchange"`
	Product           string  `json:"product"`
	Price             float64 `json:"price"`
	Quantity          int     `json:"quantity"`
	Status            string  `json:"status"`
	GUID              string  `json:"guid"`
	Tag               string  `json:"tag"`
	InstrumentToken   string  `json:"instrument_token"`
	PlacedBy          string  `json:"placed_by"`
	TradingSymbol     string  `json:"trading_symbol"`
	OrderType         string  `json:"order_type"`
	Validity          string  `json:"validity"`
	TriggerPrice      float64 `json:"trigger_price"`
	DisclosedQuantity int     `json:"disclosed_quantity"`
	TransactionType   string  `json:"transaction_type"`
	AveragePrice      float64 `json:"average_price"`
	FilledQuantity    int     `json:"filled_quantity"`
	PendingQuantity   int     `json:"pending_quantity"`
	StatusMessage     string  `json:"status_message"`
	StatusMessageRaw  string  `json:"status_message_raw"`
	ExchangeOrderID   string  `json:"exchange_order_id"`
	ParentOrderID     string  `json:"parent_order_id"`
	OrderID           string  `json:"order_id"`
	Variety           string  `json:"variety"`
	OrderTimestamp    string  `json:"order_timestamp"`
	ExchangeTimestamp string  `json:"exchange_timestamp"`
	IsAMO             bool    `json:"is_amo"`
	OrderRequestID    string  `json:"order_request_id"`
	OrderRefID        string  `json:"order_ref_id"`
}

type PositionResponse struct {
	Status string     `json:"status"`
	Data   []Position `json:"data"`
}

type OrderBookResponse struct {
	Status string  `json:"status"`
	Data   []Order `json:"data"`
}

type OrderDetailResponse struct {
	Status string `json:"status"`
	Data   Order  `json:"data"`
}
</file>

<file path="manager.go">
package upstox

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

type Manager struct {
	clientID     string
	clientSecret string
	accessToken  string
	httpClient   *http.Client
}

func NewManager(clientID, clientSecret, accessToken string) *Manager {
	return &Manager{
		clientID:     clientID,
		clientSecret: clientSecret,
		accessToken:  accessToken,
		httpClient: &http.Client{
			Timeout: 30 * time.Second,
		},
	}
}

func (m *Manager) PlaceMarketOrder(instrumentToken string, quantity int, side string) (*OrderResponse, error) {
	orderReq := OrderRequest{
		Quantity:          quantity,
		Product:           string(ProductIntraday),
		Validity:          string(ValidityDay),
		Price:             0,
		InstrumentToken:   instrumentToken,
		OrderType:         string(OrderTypeMarket),
		TransactionType:   side,
		DisclosedQuantity: 0,
		TriggerPrice:      0,
		IsAMO:             false,
		Slice:             true,
	}

	return m.placeOrder(orderReq)
}

func (m *Manager) PlaceBuyOrder(instrumentToken string, quantity int) (*OrderResponse, error) {
	return m.PlaceMarketOrder(instrumentToken, quantity, string(OrderSideBuy))
}

func (m *Manager) PlaceSellOrder(instrumentToken string, quantity int) (*OrderResponse, error) {
	return m.PlaceMarketOrder(instrumentToken, quantity, string(OrderSideSell))
}

func (m *Manager) placeOrder(orderReq OrderRequest) (*OrderResponse, error) {
	url := "https://api-hft.upstox.com/v3/order/place"

	reqBody, err := json.Marshal(orderReq)
	if err != nil {
		return nil, fmt.Errorf("failed to marshal order request: %w", err)
	}

	req, err := http.NewRequest("POST", url, bytes.NewBuffer(reqBody))
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+m.accessToken)
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("Accept", "application/json")

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API error: status %d, body: %s", resp.StatusCode, string(body))
	}

	var orderResp OrderResponse
	if err := json.Unmarshal(body, &orderResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return &orderResp, nil
}

func (m *Manager) GetPositions() ([]Position, error) {
	url := "https://api.upstox.com/v2/portfolio/short-term-positions"

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+m.accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API error: status %d, body: %s", resp.StatusCode, string(body))
	}

	var posResp PositionResponse
	if err := json.Unmarshal(body, &posResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return posResp.Data, nil
}

func (m *Manager) ClosePosition(instrumentToken string) (*OrderResponse, error) {
	positions, err := m.GetPositions()
	if err != nil {
		return nil, fmt.Errorf("failed to get positions: %w", err)
	}

	var targetPosition *Position
	for _, pos := range positions {
		if pos.InstrumentToken == instrumentToken && pos.Quantity != 0 {
			targetPosition = &pos
			break
		}
	}

	if targetPosition == nil {
		return nil, fmt.Errorf("no position found for instrument token: %s", instrumentToken)
	}

	var side string
	quantity := targetPosition.Quantity
	if quantity > 0 {
		side = string(OrderSideSell)
	} else {
		side = string(OrderSideBuy)
		quantity = -quantity
	}

	return m.PlaceMarketOrder(instrumentToken, quantity, side)
}

func (m *Manager) CloseAllPositions() ([]OrderResponse, error) {
	url := "https://api.upstox.com/v2/order/positions/exit"

	req, err := http.NewRequest("POST", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+m.accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API error: status %d, body: %s", resp.StatusCode, string(body))
	}

	var exitResp OrderResponse
	if err := json.Unmarshal(body, &exitResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	var responses []OrderResponse
	responses = append(responses, exitResp)
	return responses, nil
}

func (m *Manager) GetOrderBook() ([]Order, error) {
	url := "https://api.upstox.com/v2/order/retrieve-all"

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+m.accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API error: status %d, body: %s", resp.StatusCode, string(body))
	}

	var orderBookResp OrderBookResponse
	if err := json.Unmarshal(body, &orderBookResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return orderBookResp.Data, nil
}

func (m *Manager) GetOrderDetails(orderID string) (*Order, error) {
	url := fmt.Sprintf("https://api.upstox.com/v2/order/details?order_id=%s", orderID)

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		return nil, fmt.Errorf("failed to create request: %w", err)
	}

	req.Header.Set("Authorization", "Bearer "+m.accessToken)
	req.Header.Set("Accept", "application/json")

	resp, err := m.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to make request: %w", err)
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	if resp.StatusCode != http.StatusOK {
		return nil, fmt.Errorf("API error: status %d, body: %s", resp.StatusCode, string(body))
	}

	var orderDetailResp OrderDetailResponse
	if err := json.Unmarshal(body, &orderDetailResp); err != nil {
		return nil, fmt.Errorf("failed to unmarshal response: %w", err)
	}

	return &orderDetailResp.Data, nil
}

func (m *Manager) NewWebSocketManager(instrumentKeys []string, onPriceUpdate func(string, float64, *int32)) (*WebSocketManager, error) {
	wsURL, err := m.getAuthorizedWebSocketURL()
	if err != nil {
		return nil, fmt.Errorf("failed to get authorized WebSocket URL: %w", err)
	}

	config := WebSocketConfig{
		InstrumentKeys: instrumentKeys,
		Token:          m.accessToken,
	}

	return NewWebSocketManager(wsURL, config, onPriceUpdate), nil
}

func (m *Manager) getAuthorizedWebSocketURL() (string, error) {
	authorizeURL := "https://api.upstox.com/v3/feed/market-data-feed/authorize"
	
	req, err := http.NewRequest("GET", authorizeURL, nil)
	if err != nil {
		return "", err
	}

	req.Header.Set("Authorization", "Bearer "+m.accessToken)
	req.Header.Set("Accept", "application/json")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return "", err
	}

	var authResp AuthorizeResponse
	if err := json.Unmarshal(body, &authResp); err != nil {
		return "", err
	}

	if authResp.Status != "success" {
		return "", fmt.Errorf("authorization failed: %s", authResp.Status)
	}

	return authResp.Data.AuthorizedRedirectURI, nil
}

func (m *Manager) GetAccessToken() string {
	return m.accessToken
}

func (m *Manager) GetClientID() string {
	return m.clientID
}

func (m *Manager) GetClientSecret() string {
	return m.clientSecret
}
</file>

<file path="websocket.go">
package upstox

import (
	"context"
	"crypto/rand"
	"encoding/json"
	"fmt"
	"log"
	"sync"
	"time"

	"github.com/gorilla/websocket"
	"google.golang.org/protobuf/proto"

	pb "github.com/adeludedperson/go-upstox/pb"
)

type WebSocketManager struct {
	ws                 *websocket.Conn
	url                string
	config             WebSocketConfig
	onPriceUpdate      func(symbol string, price float64, ltq *int32)
	reconnectAttempts  int
	maxReconnectAttempts int
	reconnectDelay     time.Duration
	isConnecting       bool
	shouldReconnect    bool
	mu                 sync.RWMutex
	ctx                context.Context
	cancel             context.CancelFunc
}

type WebSocketConfig struct {
	InstrumentKeys []string
	Token          string
}

type SubscriptionMessage struct {
	GUID   string                 `json:"guid"`
	Method string                 `json:"method"`
	Data   SubscriptionMessageData `json:"data"`
}

type SubscriptionMessageData struct {
	Mode           string   `json:"mode"`
	InstrumentKeys []string `json:"instrumentKeys"`
}

func NewWebSocketManager(url string, config WebSocketConfig, onPriceUpdate func(string, float64, *int32)) *WebSocketManager {
	ctx, cancel := context.WithCancel(context.Background())
	return &WebSocketManager{
		url:                  url,
		config:               config,
		onPriceUpdate:        onPriceUpdate,
		maxReconnectAttempts: 3,
		reconnectDelay:       time.Second,
		shouldReconnect:      true,
		ctx:                  ctx,
		cancel:               cancel,
	}
}

func (wsm *WebSocketManager) connect() error {
	wsm.mu.Lock()
	defer wsm.mu.Unlock()

	if wsm.isConnecting || wsm.ws != nil {
		return nil
	}

	wsm.isConnecting = true

	dialer := websocket.Dialer{
		HandshakeTimeout: 10 * time.Second,
	}

	conn, resp, err := dialer.Dial(wsm.url, nil)
	if err != nil {
		wsm.isConnecting = false
		if resp != nil {
			log.Printf("WebSocket handshake failed with status: %s", resp.Status)
		}
		return fmt.Errorf("failed to connect to WebSocket: %w", err)
	}

	wsm.ws = conn
	wsm.reconnectAttempts = 0
	wsm.reconnectDelay = time.Second
	wsm.isConnecting = false

	go wsm.handleMessages()

	// Only subscribe if we have instrument keys
	if len(wsm.config.InstrumentKeys) > 0 {
		return wsm.subscribe()
	}
	
	return nil
}

func (wsm *WebSocketManager) subscribe() error {
	guid, err := generateGUID()
	if err != nil {
		return fmt.Errorf("failed to generate GUID: %w", err)
	}

	subscribeMsg := SubscriptionMessage{
		GUID:   guid,
		Method: "sub",
		Data: SubscriptionMessageData{
			Mode:           "ltpc",
			InstrumentKeys: wsm.config.InstrumentKeys,
		},
	}

	msgBytes, err := json.Marshal(subscribeMsg)
	if err != nil {
		return fmt.Errorf("failed to marshal subscription message: %w", err)
	}

	// Per Upstox V3 docs: "The WebSocket request message should be sent in binary format"
	return wsm.ws.WriteMessage(websocket.BinaryMessage, msgBytes)
}

func (wsm *WebSocketManager) handleMessages() {
	defer func() {
		wsm.mu.Lock()
		wsm.ws = nil
		wsm.mu.Unlock()
	}()

	for {
		select {
		case <-wsm.ctx.Done():
			return
		default:
			messageType, data, err := wsm.ws.ReadMessage()
			if err != nil {
				log.Printf("WebSocket read error: %v", err)
				wsm.handleDisconnect()
				return
			}

			if messageType == websocket.BinaryMessage {
				wsm.processMessage(data)
			} else if messageType == websocket.TextMessage {
				log.Printf("Unexpected text message: %s", string(data))
			}
		}
	}
}

func (wsm *WebSocketManager) processMessage(data []byte) {
	var feedResponse pb.FeedResponse
	if err := proto.Unmarshal(data, &feedResponse); err != nil {
		log.Printf("Failed to unmarshal protobuf message: %v", err)
		return
	}

	if feedResponse.Type != pb.Type_live_feed {
		return
	}

	for symbol, feed := range feedResponse.Feeds {
		var ltp float64
		var ltq *int32

		switch feedUnion := feed.FeedUnion.(type) {
		case *pb.Feed_Ltpc:
			ltp = float64(feedUnion.Ltpc.Ltp)
			if feedUnion.Ltpc.Ltq != 0 {
				ltqVal := int32(feedUnion.Ltpc.Ltq)
				ltq = &ltqVal
			}

		case *pb.Feed_FullFeed:
			fullFeed := feedUnion.FullFeed
			switch fullFeedUnion := fullFeed.FullFeedUnion.(type) {
			case *pb.FullFeed_MarketFF:
				if fullFeedUnion.MarketFF.Ltpc != nil {
					ltp = float64(fullFeedUnion.MarketFF.Ltpc.Ltp)
					if fullFeedUnion.MarketFF.Ltpc.Ltq != 0 {
						ltqVal := int32(fullFeedUnion.MarketFF.Ltpc.Ltq)
						ltq = &ltqVal
					}
				}
			case *pb.FullFeed_IndexFF:
				if fullFeedUnion.IndexFF.Ltpc != nil {
					ltp = float64(fullFeedUnion.IndexFF.Ltpc.Ltp)
					if fullFeedUnion.IndexFF.Ltpc.Ltq != 0 {
						ltqVal := int32(fullFeedUnion.IndexFF.Ltpc.Ltq)
						ltq = &ltqVal
					}
				}
			}

		case *pb.Feed_FirstLevelWithGreeks:
			if feedUnion.FirstLevelWithGreeks.Ltpc != nil {
				ltp = float64(feedUnion.FirstLevelWithGreeks.Ltpc.Ltp)
				if feedUnion.FirstLevelWithGreeks.Ltpc.Ltq != 0 {
					ltqVal := int32(feedUnion.FirstLevelWithGreeks.Ltpc.Ltq)
					ltq = &ltqVal
				}
			}
		}

		if ltp > 0 && wsm.onPriceUpdate != nil {
			wsm.onPriceUpdate(symbol, ltp, ltq)
		}
	}
}

func (wsm *WebSocketManager) handleDisconnect() {
	if !wsm.shouldReconnect {
		return
	}

	if wsm.reconnectAttempts < wsm.maxReconnectAttempts {
		wsm.reconnectAttempts++
		wsm.reconnectDelay *= 2

		log.Printf("Reconnecting attempt %d in %v", wsm.reconnectAttempts, wsm.reconnectDelay)
		
		time.AfterFunc(wsm.reconnectDelay, func() {
			if err := wsm.connect(); err != nil {
				log.Printf("Reconnection failed: %v", err)
			}
		})
	} else {
		log.Printf("Max reconnection attempts reached")
		wsm.Stop()
	}
}

func (wsm *WebSocketManager) Start() error {
	wsm.shouldReconnect = true
	return wsm.connect()
}

func (wsm *WebSocketManager) Stop() {
	wsm.shouldReconnect = false
	wsm.cancel()

	wsm.mu.Lock()
	defer wsm.mu.Unlock()

	if wsm.ws != nil {
		wsm.ws.Close()
		wsm.ws = nil
	}
}

func generateGUID() (string, error) {
	bytes := make([]byte, 16)
	if _, err := rand.Read(bytes); err != nil {
		return "", err
	}
	
	bytes[6] = (bytes[6] & 0x0f) | 0x40
	bytes[8] = (bytes[8] & 0x3f) | 0x80
	
	return fmt.Sprintf("%x-%x-%x-%x-%x",
		bytes[0:4], bytes[4:6], bytes[6:8], bytes[8:10], bytes[10:16]), nil
}

func (wsm *WebSocketManager) UpdateInstruments(instrumentKeys []string) error {
	wsm.mu.Lock()
	wsm.config.InstrumentKeys = instrumentKeys
	wsm.mu.Unlock()

	if wsm.ws != nil {
		return wsm.subscribe()
	}
	return nil
}
</file>

</files>
